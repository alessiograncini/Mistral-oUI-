import { isObject, pollForFileData, generateUploadThingURL, UploadThingError, fillInputRouteConfig, safeParseJSON, resolveMaybeUrlArg, getTypeFromFileName, objectKeys, contentDisposition, asArray, getStatusCodeFromError } from '@uploadthing/shared';
export { UploadThingError } from '@uploadthing/shared';
import { process, isDevelopment } from 'std-env';
import { createConsola, LogLevels } from 'consola/core';
import { VALID_ACTION_TYPES, UTFiles } from 'uploadthing/internal/types';
export { UTFiles } from 'uploadthing/internal/types';
import { lookup } from '@uploadthing/mime-types';

var version = "6.6.0";

function defaultErrorFormatter(error) {
    return {
        message: error.message
    };
}
function formatError(error, router) {
    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return errorFormatter(error);
}

const colorize = (str, level)=>{
    // TODO: Maybe check is shell supports colors
    switch(level){
        case "error":
        case "fatal":
            return `\x1b[41m\x1b[30m${str}\x1b[0m`;
        case "warn":
            return `\x1b[43m\x1b[30m${str}\x1b[0m`;
        case "info":
        case "log":
            return `\x1b[44m\x1b[30m${str}\x1b[0m`;
        case "debug":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "trace":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "success":
            return `\x1b[42m\x1b[30m${str}\x1b[0m`;
        default:
            return str;
    }
};
const icons = {
    fatal: "⨯",
    error: "⨯",
    warn: "⚠️",
    info: "ℹ",
    log: "ℹ",
    debug: "⚙",
    trace: "→",
    success: "✓"
};
function formatStack(stack) {
    const cwd = "cwd" in process && typeof process.cwd === "function" ? process.cwd() : "__UnknownCWD__";
    return "  " + stack.split("\n").splice(1).map((l)=>l.trim().replace("file://", "").replace(cwd + "/", "")).join("\n  ");
}
function formatArgs(args) {
    const fmtArgs = args.map((arg)=>{
        if (isObject(arg) && typeof arg.stack === "string") {
            return arg.message + "\n" + formatStack(arg.stack);
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return arg;
    });
    return fmtArgs.map((arg)=>{
        if (typeof arg === "string") {
            return arg;
        }
        return JSON.stringify(arg, null, 4);
    });
}
const logger = createConsola({
    reporters: [
        {
            log: (logObj)=>{
                const { type, tag, date, args } = logObj;
                const icon = icons[type];
                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);
                const lines = formatArgs(args).join(" ") // concat all arguments to one space-separated string (like console does)
                .split("\n") // split all the newlines (e.g. from logged JSON.stringified objects)
                .map((l)=>logPrefix + " " + l) // prepend the log prefix to each line
                .join("\n"); // join all the lines back together
                // eslint-disable-next-line no-console
                console.log(lines);
            }
        }
    ],
    defaults: {
        tag: "UPLOADTHING"
    }
});
const initLogger = (level)=>{
    // logger.wrapConsole();
    logger.level = LogLevels[level ?? "info"];
};

const isValidResponse = (response)=>{
    if (!response.ok) return false;
    if (response.status >= 400) return false;
    if (!response.headers.has("x-uploadthing-version")) return false;
    return true;
};
const conditionalDevServer = async (opts)=>{
    const fileData = await pollForFileData({
        url: generateUploadThingURL(`/api/pollUpload/${opts.fileKey}`),
        apiKey: opts.apiKey,
        sdkVersion: version,
        fetch: opts.fetch
    }, async (json)=>{
        const file = json.fileData;
        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
        if (!callbackUrl.startsWith("http")) callbackUrl = "http://" + callbackUrl;
        logger.info("SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
        try {
            const response = await opts.fetch(callbackUrl, {
                method: "POST",
                body: JSON.stringify({
                    status: "uploaded",
                    metadata: JSON.parse(file.metadata ?? "{}"),
                    file: {
                        url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,
                        key: opts.fileKey,
                        name: file.fileName,
                        size: file.fileSize,
                        type: file.fileType,
                        customId: file.customId
                    }
                }),
                headers: {
                    "uploadthing-hook": "callback"
                }
            });
            if (isValidResponse(response)) {
                logger.success("Successfully simulated callback for file", opts.fileKey);
            } else {
                throw new Error("Invalid response");
            }
        } catch (e) {
            logger.error(`Failed to simulate callback for file '${opts.fileKey}'. Is your webhook configured correctly?`);
            logger.error(`  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal`);
            logger.error(`  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues`);
        }
        return file;
    });
    if (fileData !== undefined) return fileData;
    logger.error(`Failed to simulate callback for file ${opts.fileKey}`);
    throw new UploadThingError({
        code: "UPLOAD_FAILED",
        message: "File took too long to upload"
    });
};

function getParseFn(parser) {
    if (typeof parser.parse === "function") {
        return parser.parse;
    }
    throw new Error("Invalid parser");
}

/**
 * Creates a wrapped fetch that will always forward a few headers to the server.
 */ const createUTFetch = (apiKey, fetch, fePackage, beAdapter)=>{
    return async (endpoint, payload)=>{
        const response = await fetch(generateUploadThingURL(endpoint), {
            method: "POST",
            body: JSON.stringify(payload),
            headers: {
                "Content-Type": "application/json",
                "x-uploadthing-api-key": apiKey,
                "x-uploadthing-version": version,
                "x-uploadthing-fe-package": fePackage,
                "x-uploadthing-be-adapter": beAdapter
            }
        });
        return response;
    };
};
const fileCountLimitHit = (files, routeConfig)=>{
    const counts = {};
    files.forEach((file)=>{
        const type = getTypeFromFileName(file.name, objectKeys(routeConfig));
        if (!counts[type]) {
            counts[type] = 1;
        } else {
            counts[type] += 1;
        }
    });
    for(const _key in counts){
        const key = _key;
        const count = counts[key];
        const limit = routeConfig[key]?.maxFileCount;
        if (!limit) {
            logger.error(routeConfig, key);
            throw new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid config during file count",
                cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`
            });
        }
        if (count > limit) {
            return {
                limitHit: true,
                type: key,
                limit,
                count
            };
        }
    }
    return {
        limitHit: false
    };
};
const buildRequestHandler = (opts, adapter)=>{
    return async (input)=>{
        const isDev = opts.config?.isDev ?? isDevelopment;
        const fetch = opts.config?.fetch ?? globalThis.fetch;
        if (isDev) {
            logger.info("UploadThing dev server is now running!");
        }
        const { router, config } = opts;
        const preferredOrEnvSecret = config?.uploadthingSecret ?? process.env.UPLOADTHING_SECRET;
        const req = input.req;
        const url = new URL(req.url);
        // Get inputs from query and params
        const params = url.searchParams;
        const uploadthingHook = req.headers.get("uploadthing-hook") ?? undefined;
        const slug = params.get("slug") ?? undefined;
        const actionType = params.get("actionType") ?? undefined;
        const utFrontendPackage = req.headers.get("x-uploadthing-package") ?? "unknown";
        const clientVersion = req.headers.get("x-uploadthing-version");
        if (clientVersion != null && clientVersion !== version) {
            logger.error("Client version mismatch");
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Client version mismatch",
                cause: `Server version: ${version}, Client version: ${clientVersion}`
            });
        }
        // Validate inputs
        if (!slug) {
            logger.error("No slug provided in params:", params);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "No slug provided in params"
            });
        }
        if (slug && typeof slug !== "string") {
            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;
            logger.error(msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`slug` must be a string",
                cause: msg
            });
        }
        if (actionType && typeof actionType !== "string") {
            const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;
            logger.error(msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`actionType` must be a string",
                cause: msg
            });
        }
        if (uploadthingHook && typeof uploadthingHook !== "string") {
            const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`uploadthingHook` must be a string",
                cause: msg
            });
        }
        if (!preferredOrEnvSecret) {
            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;
            logger.error(msg);
            return new UploadThingError({
                code: "MISSING_ENV",
                message: `No secret provided`,
                cause: msg
            });
        }
        if (!preferredOrEnvSecret.startsWith("sk_")) {
            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;
            logger.error(msg);
            return new UploadThingError({
                code: "MISSING_ENV",
                message: "Invalid API key. API keys must start with 'sk_'.",
                cause: msg
            });
        }
        if (utFrontendPackage && typeof utFrontendPackage !== "string") {
            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;
            logger.error(msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`x-uploadthing-package` must be a string. eg. '@uploadthing/react'",
                cause: msg
            });
        }
        const uploadable = router[slug];
        if (!uploadable) {
            const msg = `No file route found for slug ${slug}`;
            logger.error(msg);
            return new UploadThingError({
                code: "NOT_FOUND",
                message: msg
            });
        }
        const utFetch = createUTFetch(preferredOrEnvSecret, fetch, utFrontendPackage, adapter);
        logger.debug("All request input is valid", {
            slug,
            actionType,
            uploadthingHook
        });
        if (uploadthingHook === "callback") {
            // This is when we receive the webhook from uploadthing
            const maybeReqBody = await safeParseJSON(req);
            logger.debug("Handling callback request with input:", maybeReqBody);
            if (maybeReqBody instanceof Error) {
                logger.error("Invalid request body", maybeReqBody);
                return new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid request body",
                    cause: maybeReqBody
                });
            }
            const resolverArgs = {
                file: maybeReqBody.file,
                metadata: maybeReqBody.metadata
            };
            logger.debug("Running 'onUploadComplete' callback with input:", resolverArgs);
            const res = await uploadable.resolver(resolverArgs);
            const payload = {
                fileKey: maybeReqBody.file.key,
                callbackData: res ?? null
            };
            logger.debug("'onUploadComplete' callback finished. Sending response to UploadThing:", payload);
            const callbackResponse = await utFetch("/api/serverCallback", payload);
            logger.debug("UploadThing responded with status:", callbackResponse.status);
            return {
                status: 200,
                body: null
            };
        }
        if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {
            // This would either be someone spamming or the AWS webhook
            const msg = `Expected ${VALID_ACTION_TYPES.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${actionType}"`;
            logger.error("Invalid action type.", msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid action type ${actionType}`,
                message: msg
            });
        }
        switch(actionType){
            case "upload":
                {
                    const maybeInput = await safeParseJSON(req);
                    if (maybeInput instanceof Error) {
                        logger.error("Invalid request body", maybeInput);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid request body",
                            cause: maybeInput
                        });
                    }
                    logger.debug("Handling upload request with input:", maybeInput);
                    const { files, input: userInput } = maybeInput;
                    // Validate without Zod (for now)
                    if (!Array.isArray(files) || !files.every((f)=>isObject(f) && typeof f.name === "string" && typeof f.size === "number" && typeof f.type === "string")) {
                        const msg = `Expected files to be of type '{name:string, size:number, type:string}[]', got '${JSON.stringify(files)}'`;
                        logger.error(msg);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Files must be an array of objects with name and size",
                            cause: msg
                        });
                    }
                    // validate the input
                    let parsedInput = {};
                    try {
                        logger.debug("Parsing input");
                        const inputParser = uploadable._def.inputParser;
                        parsedInput = await getParseFn(inputParser)(userInput);
                        logger.debug("Input parsed successfully", parsedInput);
                    } catch (error) {
                        logger.error("An error occurred trying to parse input:", error);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid input.",
                            cause: error
                        });
                    }
                    let metadata = {};
                    try {
                        logger.debug("Running middleware");
                        metadata = await uploadable._def.middleware({
                            ...input.middlewareArgs,
                            input: parsedInput,
                            files
                        });
                        logger.debug("Middleware finished successfully with:", metadata);
                    } catch (error) {
                        logger.error("An error occurred in your middleware function:", error);
                        if (error instanceof UploadThingError) return error;
                        return new UploadThingError({
                            code: "INTERNAL_SERVER_ERROR",
                            message: "Failed to run middleware.",
                            cause: error
                        });
                    }
                    if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {
                        const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;
                        logger.error(msg);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Files override must have the same length as files",
                            cause: msg
                        });
                    }
                    // Attach customIds from middleware to the files
                    const filesWithCustomIds = files.map((file, idx)=>{
                        const theirs = metadata[UTFiles]?.[idx];
                        if (theirs && theirs.size !== file.size) {
                            logger.warn("File size mismatch. Reverting to original size");
                        }
                        return {
                            name: theirs?.name ?? file.name,
                            size: file.size,
                            customId: theirs?.customId
                        };
                    });
                    // FILL THE ROUTE CONFIG so the server only has one happy path
                    let parsedConfig;
                    try {
                        logger.debug("Parsing route config", uploadable._def.routerConfig);
                        parsedConfig = fillInputRouteConfig(uploadable._def.routerConfig);
                        logger.debug("Route config parsed successfully", parsedConfig);
                    } catch (error) {
                        logger.error("Invalid route config", error);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid config.",
                            cause: error
                        });
                    }
                    try {
                        logger.debug("Checking file count limit", files);
                        const { limitHit, count, limit, type } = fileCountLimitHit(files, parsedConfig);
                        if (limitHit) {
                            const msg = `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`;
                            logger.error(msg);
                            return new UploadThingError({
                                code: "BAD_REQUEST",
                                message: "File limit exceeded",
                                cause: msg
                            });
                        }
                        logger.debug("File count limit check passed");
                    } catch (error) {
                        logger.error("Invalid route config", error);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid config.",
                            cause: error
                        });
                    }
                    const callbackUrl = resolveCallbackUrl({
                        config,
                        req,
                        url,
                        isDev
                    });
                    logger.debug("Retrieving presigned URLs from UploadThing. Callback URL is:", callbackUrl.href);
                    const uploadthingApiResponse = await utFetch("/api/prepareUpload", {
                        files: filesWithCustomIds,
                        routeConfig: parsedConfig,
                        metadata,
                        callbackUrl: callbackUrl.origin + callbackUrl.pathname,
                        callbackSlug: slug
                    });
                    // This is when we send the response back to the user's form so they can submit the files
                    const parsedResponse = await safeParseJSON(uploadthingApiResponse);
                    if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {
                        logger.error("Unable to get presigned URLs", parsedResponse);
                        return new UploadThingError({
                            code: "URL_GENERATION_FAILED",
                            message: "Unable to get presigned urls",
                            cause: parsedResponse
                        });
                    }
                    logger.debug("UploadThing responded with:", parsedResponse);
                    logger.debug("Sending presigned URLs to client");
                    // This is when we send the response back to the user's form so they can submit the files
                    let promise = undefined;
                    if (isDev) {
                        promise = Promise.all(parsedResponse.map((file)=>conditionalDevServer({
                                fileKey: file.key,
                                apiKey: preferredOrEnvSecret,
                                fetch
                            }).catch((error)=>{
                                logger.error("Err", error);
                            })));
                    }
                    return {
                        cleanup: promise,
                        body: parsedResponse,
                        status: 200
                    };
                }
            case "multipart-complete":
                {
                    const maybeReqBody = await safeParseJSON(req);
                    if (maybeReqBody instanceof Error) {
                        logger.error("Invalid request body", maybeReqBody);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid request body",
                            cause: maybeReqBody
                        });
                    }
                    logger.debug("Handling multipart-complete request with input:", maybeReqBody);
                    logger.debug("Notifying UploadThing that multipart upload is complete");
                    const completeRes = await utFetch("/api/completeMultipart", {
                        fileKey: maybeReqBody.fileKey,
                        uploadId: maybeReqBody.uploadId,
                        etags: maybeReqBody.etags
                    });
                    if (!completeRes.ok) {
                        logger.error("Failed to notify UploadThing that multipart upload is complete");
                        return new UploadThingError({
                            code: "UPLOAD_FAILED",
                            message: "Failed to complete multipart upload",
                            cause: completeRes
                        });
                    }
                    logger.debug("UploadThing responded with:", completeRes.status);
                    return {
                        status: 200,
                        body: null
                    };
                }
            case "failure":
                {
                    const maybeReqBody = await safeParseJSON(req);
                    if (maybeReqBody instanceof Error) {
                        logger.error("Invalid request body", maybeReqBody);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid request body",
                            cause: maybeReqBody
                        });
                    }
                    const { fileKey, uploadId } = maybeReqBody;
                    logger.debug("Handling failure request with input:", maybeReqBody);
                    logger.debug("Notifying UploadThing that upload failed");
                    // Tell uploadthing to mark the upload as failed
                    const uploadthingApiResponse = await utFetch("/api/failureCallback", {
                        fileKey,
                        uploadId
                    });
                    if (!uploadthingApiResponse.ok) {
                        const parsedResponse = await safeParseJSON(uploadthingApiResponse);
                        logger.error("Failed to mark upload as failed", parsedResponse);
                        return new UploadThingError({
                            code: "INTERNAL_SERVER_ERROR",
                            message: "Unable to mark upload as failed",
                            cause: parsedResponse
                        });
                    }
                    logger.debug("UploadThing responded with:", uploadthingApiResponse);
                    logger.debug("Running 'onUploadError' callback");
                    try {
                        // Run the onUploadError callback
                        uploadable._def.onUploadError({
                            error: new UploadThingError({
                                code: "UPLOAD_FAILED",
                                message: `Upload failed for ${fileKey}`
                            }),
                            fileKey
                        });
                    } catch (error) {
                        logger.error("Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.", error);
                        return new UploadThingError({
                            code: "INTERNAL_SERVER_ERROR",
                            message: "Failed to run onUploadError callback",
                            cause: error
                        });
                    }
                    return {
                        status: 200,
                        body: null
                    };
                }
            default:
                {
                    // This should never happen
                    return new UploadThingError({
                        code: "BAD_REQUEST",
                        message: `Invalid action type`
                    });
                }
        }
    };
};
function resolveCallbackUrl(opts) {
    let callbackUrl = opts.url;
    if (opts.config?.callbackUrl) {
        callbackUrl = resolveMaybeUrlArg(opts.config.callbackUrl);
    } else if (process.env.UPLOADTHING_URL) {
        callbackUrl = resolveMaybeUrlArg(process.env.UPLOADTHING_URL);
    }
    if (opts.isDev || !callbackUrl.host.includes("localhost")) {
        return callbackUrl;
    }
    // Production builds have to have a public URL so UT can send webhook
    // Parse the URL from the headers
    const headers = opts.req.headers;
    let parsedFromHeaders = headers.get("origin") ?? headers.get("referer") ?? headers.get("host") ?? headers.get("x-forwarded-host");
    if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
        parsedFromHeaders = (headers.get("x-forwarded-proto") ?? "https") + "://" + parsedFromHeaders;
    }
    if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
        // Didn't find a valid URL in the headers, log a warning and use the original url anyway
        logger.warn("You are using a localhost callback url in production which is not supported.", "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production");
        return callbackUrl;
    }
    return resolveMaybeUrlArg(parsedFromHeaders);
}
const buildPermissionsInfoHandler = (opts)=>{
    return ()=>{
        const r = opts.router;
        const permissions = Object.keys(r).map((k)=>{
            const route = r[k];
            const config = fillInputRouteConfig(route._def.routerConfig);
            return {
                slug: k,
                config
            };
        });
        return permissions;
    };
};

function incompatibleNodeGuard() {
    if (typeof process === "undefined") return;
    let major;
    let minor;
    const maybeNodeVersion = process.versions?.node?.split(".");
    if (maybeNodeVersion) {
        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));
    }
    const maybeNodePath = process.env?.NODE;
    if (!major && maybeNodePath) {
        const nodeVersion = /v(\d+)\.(\d+)\.(\d+)/.exec(maybeNodePath)?.[0];
        if (nodeVersion) {
            [major, minor] = nodeVersion.substring(1).split(".").map((v)=>parseInt(v, 10));
        }
    }
    if (!major || !minor) return;
    // Require ^18.13.0
    if (major > 18) return;
    if (major === 18 && minor >= 13) return;
    logger.fatal(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`);
    // Kill the process if it isn't going to work correctly anyway
    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
    process.exit?.(1);
}

function internalCreateBuilder(initDef = {}) {
    const _def = {
        // Default router config
        routerConfig: {
            image: {
                maxFileSize: "4MB"
            }
        },
        inputParser: {
            parse: ()=>undefined,
            _input: undefined,
            _output: undefined
        },
        middleware: ()=>({}),
        onUploadError: ()=>({}),
        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
        // Overload with properties passed in
        ...initDef
    };
    return {
        input (userParser) {
            return internalCreateBuilder({
                ..._def,
                inputParser: userParser
            });
        },
        middleware (userMiddleware) {
            return internalCreateBuilder({
                ..._def,
                middleware: userMiddleware
            });
        },
        onUploadComplete (userUploadComplete) {
            return {
                _def,
                resolver: userUploadComplete
            };
        },
        onUploadError (userOnUploadError) {
            return internalCreateBuilder({
                ..._def,
                onUploadError: userOnUploadError
            });
        }
    };
}
function createBuilder(opts) {
    return (input)=>{
        return internalCreateBuilder({
            routerConfig: input,
            ...opts
        });
    };
}

const maybeParseResponseXML = (maybeXml)=>{
    const codeMatch = maybeXml.match(/<Code>(.*?)<\/Code>/s);
    const messageMatch = maybeXml.match(/<Message>(.*?)<\/Message>/s);
    const code = codeMatch?.[1];
    const message = messageMatch?.[1];
    if (!code || !message) return null;
    return {
        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,
        message
    };
};
/**
 * Map S3 error codes to UploadThing error codes
 *
 * This is a subset of the S3 error codes, based on what seemed most likely to
 * occur in uploadthing. For a full list of S3 error codes, see:
 * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html
 */ const DEFAULT_ERROR_CODE = "UPLOAD_FAILED";
const s3CodeToUploadThingCode = {
    AccessDenied: "FORBIDDEN",
    EntityTooSmall: "TOO_SMALL",
    EntityTooLarge: "TOO_LARGE",
    ExpiredToken: "FORBIDDEN",
    IncorrectNumberOfFilesInPostRequest: "TOO_MANY_FILES",
    InternalError: "INTERNAL_SERVER_ERROR",
    KeyTooLongError: "KEY_TOO_LONG",
    MaxMessageLengthExceeded: "TOO_LARGE"
};

/**
 * Used by server uploads where progress is not needed.
 * Uses normal fetch API.
 */ async function uploadPart(opts, retryCount = 0) {
    const s3Res = await opts.fetch(opts.url, {
        method: "PUT",
        body: opts.chunk,
        headers: {
            "Content-Type": opts.contentType,
            "Content-Disposition": contentDisposition(opts.contentDisposition, opts.fileName)
        }
    });
    if (s3Res.ok) {
        const etag = s3Res.headers.get("Etag");
        if (!etag) {
            throw new UploadThingError({
                code: "UPLOAD_FAILED",
                message: "Missing Etag header from uploaded part"
            });
        }
        return etag.replace(/"/g, "");
    }
    if (retryCount < opts.maxRetries) {
        // Retry after exponential backoff
        const delay = 2 ** retryCount * 1000;
        await new Promise((r)=>setTimeout(r, delay));
        return uploadPart(opts, retryCount++);
    }
    // Max retries exceeded, tell UT server that upload failed
    await opts.fetch(generateUploadThingURL("/api/failureCallback"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: opts.key
        }),
        headers: opts.utRequestHeaders
    });
    const text = await s3Res.text();
    const parsed = maybeParseResponseXML(text);
    if (parsed?.message) {
        throw new UploadThingError({
            code: "UPLOAD_FAILED",
            message: parsed.message
        });
    }
    throw new UploadThingError({
        code: "UPLOAD_FAILED",
        message: "Failed to upload file to storage provider",
        cause: s3Res
    });
}

function guardServerOnly() {
    if (typeof window !== "undefined") {
        throw new UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "The `utapi` can only be used on the server."
        });
    }
}
function getApiKeyOrThrow(apiKey) {
    if (apiKey) return apiKey;
    if (process.env.UPLOADTHING_SECRET) return process.env.UPLOADTHING_SECRET;
    throw new UploadThingError({
        code: "MISSING_ENV",
        message: "Missing `UPLOADTHING_SECRET` env variable."
    });
}
const uploadFilesInternal = async (data, opts)=>{
    // Request presigned URLs for each file
    const fileData = data.files.map((file)=>({
            name: file.name ?? "unnamed-blob",
            type: file.type,
            size: file.size,
            ..."customId" in file ? {
                customId: file.customId
            } : {}
        }));
    logger.debug("Getting presigned URLs for files", fileData);
    const res = await opts.fetch(generateUploadThingURL("/api/uploadFiles"), {
        method: "POST",
        headers: opts.utRequestHeaders,
        cache: "no-store",
        body: JSON.stringify({
            files: fileData,
            metadata: data.metadata,
            contentDisposition: data.contentDisposition,
            acl: data.acl
        })
    });
    if (!res.ok) {
        const error = await UploadThingError.fromResponse(res);
        logger.debug("Failed getting presigned URLs:", error);
        throw error;
    }
    const json = await res.json();
    logger.debug("Got presigned URLs:", json.data);
    logger.debug("Starting uploads...");
    // Upload each file to S3 in chunks using multi-part uploads
    const uploads = await Promise.allSettled(data.files.map(async (file, i)=>{
        const presigned = json.data[i];
        if (!presigned) {
            logger.error("Failed to generate presigned URL for file:", file, presigned);
            throw new UploadThingError({
                code: "URL_GENERATION_FAILED",
                message: "Failed to generate presigned URL",
                cause: JSON.stringify(presigned)
            });
        }
        if ("urls" in presigned) {
            await uploadMultipart(file, presigned, {
                ...opts
            });
        } else {
            await uploadPresignedPost(file, presigned, {
                ...opts
            });
        }
        // Poll for file to be available
        logger.debug("Polling for file data...");
        await pollForFileData({
            url: generateUploadThingURL(`/api/pollUpload/${presigned.key}`),
            apiKey: opts.utRequestHeaders["x-uploadthing-api-key"],
            sdkVersion: version,
            fetch: opts.fetch
        });
        logger.debug("Polling complete.");
        return {
            key: presigned.key,
            url: presigned.fileUrl,
            name: file.name,
            size: file.size,
            type: file.type,
            customId: "customId" in file ? file.customId ?? null : null
        };
    }));
    logger.debug("All uploads complete, aggregating results...");
    return uploads.map((upload)=>{
        if (upload.status === "fulfilled") {
            const data = upload.value;
            return {
                data,
                error: null
            };
        }
        // We only throw UploadThingErrors, so this is safe
        const reason = upload.reason;
        const error = UploadThingError.toObject(reason);
        return {
            data: null,
            error
        };
    });
};
async function uploadMultipart(file, presigned, opts) {
    logger.debug("Uploading file", file.name, "with", presigned.urls.length, "chunks of size", presigned.chunkSize, "bytes each");
    const etags = await Promise.all(presigned.urls.map(async (url, index)=>{
        const offset = presigned.chunkSize * index;
        const end = Math.min(offset + presigned.chunkSize, file.size);
        const chunk = file.slice(offset, end);
        const etag = await uploadPart({
            fetch: opts.fetch,
            url,
            chunk: chunk,
            contentDisposition: presigned.contentDisposition,
            contentType: file.type,
            fileName: file.name,
            maxRetries: 10,
            key: presigned.key,
            utRequestHeaders: opts.utRequestHeaders
        });
        logger.debug("Part", index + 1, "uploaded successfully:", etag);
        return {
            tag: etag,
            partNumber: index + 1
        };
    }));
    logger.debug("File", file.name, "uploaded successfully. Notifying UploadThing to complete multipart upload.");
    // Complete multipart upload
    const completionRes = await opts.fetch(generateUploadThingURL("/api/completeMultipart"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: presigned.key,
            uploadId: presigned.uploadId,
            etags
        }),
        headers: opts.utRequestHeaders
    });
    logger.debug("UploadThing responsed with status:", completionRes.status);
}
async function uploadPresignedPost(file, presigned, opts) {
    logger.debug("Uploading file", file.name, "using presigned POST URL");
    const formData = new FormData();
    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));
    formData.append("file", file); // File data **MUST GO LAST**
    const res = await opts.fetch(presigned.url, {
        method: "POST",
        body: formData,
        headers: new Headers({
            Accept: "application/xml"
        })
    });
    if (!res.ok) {
        const text = await res.text();
        logger.error("Failed to upload file:", text);
        throw new UploadThingError({
            code: "UPLOAD_FAILED",
            message: "Failed to upload file",
            cause: text
        });
    }
    logger.debug("File", file.name, "uploaded successfully");
}
function parseTimeToSeconds(time) {
    const match = time.toString().split(/(\d+)/).filter(Boolean);
    const num = Number(match[0]);
    const unit = (match[1] ?? "s").trim().slice(0, 1);
    const multiplier = {
        s: 1,
        m: 60,
        h: 3600,
        d: 86400
    }[unit];
    return num * multiplier;
}

/**
 * Extension of the Blob class that simplifies setting the `name` and `customId` properties,
 * similar to the built-in File class from Node > 20.
 */ class UTFile extends Blob {
    constructor(parts, name, options){
        const optionsWithDefaults = {
            ...options,
            type: options?.type ?? (lookup(name) || undefined),
            lastModified: options?.lastModified ?? Date.now()
        };
        super(parts, optionsWithDefaults);
        this.name = name;
        this.customId = optionsWithDefaults.customId;
        this.lastModified = optionsWithDefaults.lastModified;
    }
}
class UTApi {
    constructor(opts){
        /**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   *
   * @example
   * await deleteFiles("myCustomIdentifier", { keyType: "customId" })
   */ this.deleteFiles = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            return this.requestUploadThing("/api/deleteFile", keyType === "fileKey" ? {
                fileKeys: asArray(keys)
            } : {
                customIds: asArray(keys)
            }, "An unknown error occurred while deleting files.");
        };
        /**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */ this.getFileUrls = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            const json = await this.requestUploadThing("/api/getFileUrl", keyType === "fileKey" ? {
                fileKeys: asArray(keys)
            } : {
                customIds: asArray(keys)
            }, "An unknown error occurred while retrieving file URLs.");
            return json.data;
        };
        /**
   * Request file list from UploadThing storage.
   * @param {object} opts
   * @param {number} opts.limit The maximum number of files to return
   * @param {number} opts.offset The number of files to skip
   *
   * @example
   * const data = await listFiles({ limit: 1 });
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */ this.listFiles = async (opts)=>{
            guardServerOnly();
            const json = await this.requestUploadThing("/api/listFiles", {
                ...opts
            }, "An unknown error occurred while listing files.");
            return json.files;
        };
        this.renameFiles = async (updates)=>{
            guardServerOnly();
            return this.requestUploadThing("/api/renameFiles", {
                updates: asArray(updates)
            }, "An unknown error occurred while renaming files.");
        };
        /** @deprecated Use {@link renameFiles} instead. */ this.renameFile = this.renameFiles;
        this.getUsageInfo = async ()=>{
            guardServerOnly();
            return this.requestUploadThing("/api/getUsageInfo", {}, "An unknown error occurred while getting usage info.");
        };
        /** Request a presigned url for a private file(s) */ this.getSignedURL = async (key, opts)=>{
            guardServerOnly();
            const expiresIn = opts?.expiresIn ? parseTimeToSeconds(opts.expiresIn) : undefined;
            const { keyType = this.defaultKeyType } = opts ?? {};
            if (opts?.expiresIn && isNaN(expiresIn)) {
                throw new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds."
                });
            }
            if (expiresIn && expiresIn > 86400 * 7) {
                throw new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be less than 7 days (604800 seconds)."
                });
            }
            const json = await this.requestUploadThing("/api/requestFileAccess", keyType === "fileKey" ? {
                fileKey: key,
                expiresIn
            } : {
                customId: key,
                expiresIn
            }, "An unknown error occurred while retrieving presigned URLs.");
            return json.url;
        };
        this.fetch = opts?.fetch ?? globalThis.fetch;
        this.apiKey = opts?.apiKey ?? process.env.UPLOADTHING_SECRET;
        this.defaultHeaders = {
            "Content-Type": "application/json",
            "x-uploadthing-api-key": this.apiKey,
            "x-uploadthing-version": version,
            "x-uploadthing-be-adapter": "server-sdk"
        };
        this.defaultKeyType = opts?.defaultKeyType ?? "fileKey";
        initLogger(opts?.logLevel);
        // Assert some stuff
        guardServerOnly();
        getApiKeyOrThrow(this.apiKey);
        if (!this.apiKey?.startsWith("sk_")) {
            throw new UploadThingError({
                code: "MISSING_ENV",
                message: "Invalid API key. API keys must start with `sk_`."
            });
        }
        incompatibleNodeGuard();
    }
    async requestUploadThing(pathname, body, fallbackErrorMessage) {
        const url = generateUploadThingURL(pathname);
        logger.debug("Requesting UploadThing:", {
            url,
            body,
            headers: this.defaultHeaders
        });
        const res = await this.fetch(url, {
            method: "POST",
            cache: "no-store",
            headers: this.defaultHeaders,
            body: JSON.stringify(body)
        });
        logger.debug("UploadThing responsed with status:", res.status);
        const json = await res.json();
        if (!res.ok || "error" in json) {
            logger.error("Error:", json);
            throw new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "error" in json && typeof json.error === "string" ? json.error : fallbackErrorMessage
            });
        }
        logger.debug("UploadThing response:", json);
        return json;
    }
    async uploadFiles(files, opts) {
        guardServerOnly();
        const uploads = await uploadFilesInternal({
            files: asArray(files),
            metadata: opts?.metadata ?? {},
            contentDisposition: opts?.contentDisposition ?? "inline",
            acl: opts?.acl
        }, {
            fetch: this.fetch,
            utRequestHeaders: this.defaultHeaders
        });
        const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
        logger.debug("Finished uploading:", uploadFileResponse);
        return uploadFileResponse;
    }
    async uploadFilesFromUrl(urls, opts) {
        guardServerOnly();
        const formData = new FormData();
        formData.append("metadata", JSON.stringify(opts?.metadata ?? {}));
        const downloadErrors = {};
        const files = await Promise.all(asArray(urls).map(async (_url, index)=>{
            let url = isObject(_url) ? _url.url : _url;
            if (typeof url === "string") {
                // since dataurls will result in name being too long, tell the user
                // to use uploadFiles instead.
                if (url.startsWith("data:")) {
                    downloadErrors[index] = UploadThingError.toObject(new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only."
                    }));
                    return undefined;
                }
                url = new URL(url);
            }
            const { name = url.pathname.split("/").pop() ?? "unknown-filename", customId = undefined } = isObject(_url) ? _url : {};
            // Download the file on the user's server to avoid egress charges
            logger.debug("Downloading file:", url);
            const fileResponse = await this.fetch(url);
            if (!fileResponse.ok) {
                downloadErrors[index] = UploadThingError.toObject(new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Failed to download requested file.",
                    cause: fileResponse
                }));
                return undefined;
            }
            logger.debug("Finished downloading file. Reading blob...");
            const blob = await fileResponse.blob();
            logger.debug("Finished reading blob.");
            return new UTFile([
                blob
            ], name, {
                customId
            });
        })).then((files)=>files.filter((x)=>x !== undefined));
        logger.debug("Uploading files:", files);
        const uploads = await uploadFilesInternal({
            files,
            metadata: opts?.metadata ?? {},
            contentDisposition: opts?.contentDisposition ?? "inline",
            acl: opts?.acl
        }, {
            fetch: this.fetch,
            utRequestHeaders: this.defaultHeaders
        });
        /** Put it all back together, preserve the order of files */ const responses = asArray(urls).map((_, index)=>{
            if (downloadErrors[index]) {
                return {
                    data: null,
                    error: downloadErrors[index]
                };
            }
            return uploads.shift();
        });
        /** Return single object or array based on input urls */ const uploadFileResponse = Array.isArray(urls) ? responses : responses[0];
        logger.debug("Finished uploading:", uploadFileResponse);
        return uploadFileResponse;
    }
}

const createUploadthing = (opts)=>createBuilder(opts);
/** @internal */ const INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts, adapter)=>{
    initLogger(opts.config?.logLevel);
    incompatibleNodeGuard();
    const requestHandler = buildRequestHandler(opts, adapter);
    const getBuildPerms = buildPermissionsInfoHandler(opts);
    const POST = async (request)=>{
        const req = request instanceof Request ? request : request.request;
        const response = await requestHandler({
            req,
            middlewareArgs: {
                req,
                res: undefined,
                event: undefined
            }
        });
        if (response instanceof UploadThingError) {
            return new Response(JSON.stringify(formatError(response, opts.router)), {
                status: getStatusCodeFromError(response),
                headers: {
                    "x-uploadthing-version": version
                }
            });
        }
        if (response.status !== 200) {
            // We messed up - this should never happen
            return new Response("An unknown error occurred", {
                status: 500,
                headers: {
                    "x-uploadthing-version": version
                }
            });
        }
        const res = new Response(JSON.stringify(response.body), {
            status: response.status,
            headers: {
                "x-uploadthing-version": version
            }
        });
        // @ts-expect-error - this is a custom property
        res.cleanup = response.cleanup;
        return res;
    };
    const GET = (request)=>{
        return new Response(JSON.stringify(getBuildPerms()), {
            status: 200,
            headers: {
                "x-uploadthing-version": version
            }
        });
    };
    return {
        GET,
        POST
    };
};
const createRouteHandler = (opts)=>INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, "server");
const extractRouterConfig = (router)=>buildPermissionsInfoHandler({
        router
    })();
/**
 * @deprecated Use {@link createRouteHandler} instead
 */ const createServerHandler = createRouteHandler;

export { INTERNAL_DO_NOT_USE_createRouteHandlerCore, UTApi, UTFile, createRouteHandler, createServerHandler, createUploadthing, extractRouterConfig };
