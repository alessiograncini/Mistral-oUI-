import { Router } from 'express';
import { isObject, pollForFileData, generateUploadThingURL, UploadThingError, safeParseJSON, fillInputRouteConfig, resolveMaybeUrlArg, getTypeFromFileName, objectKeys, getStatusCodeFromError } from '@uploadthing/shared';
import { process, isDevelopment } from 'std-env';
import { createConsola, LogLevels } from 'consola/core';
import { VALID_ACTION_TYPES, UTFiles } from 'uploadthing/internal/types';
export { UTFiles } from 'uploadthing/internal/types';

var version = "6.6.0";

function defaultErrorFormatter(error) {
    return {
        message: error.message
    };
}
function formatError(error, router) {
    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return errorFormatter(error);
}

const colorize = (str, level)=>{
    // TODO: Maybe check is shell supports colors
    switch(level){
        case "error":
        case "fatal":
            return `\x1b[41m\x1b[30m${str}\x1b[0m`;
        case "warn":
            return `\x1b[43m\x1b[30m${str}\x1b[0m`;
        case "info":
        case "log":
            return `\x1b[44m\x1b[30m${str}\x1b[0m`;
        case "debug":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "trace":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "success":
            return `\x1b[42m\x1b[30m${str}\x1b[0m`;
        default:
            return str;
    }
};
const icons = {
    fatal: "⨯",
    error: "⨯",
    warn: "⚠️",
    info: "ℹ",
    log: "ℹ",
    debug: "⚙",
    trace: "→",
    success: "✓"
};
function formatStack(stack) {
    const cwd = "cwd" in process && typeof process.cwd === "function" ? process.cwd() : "__UnknownCWD__";
    return "  " + stack.split("\n").splice(1).map((l)=>l.trim().replace("file://", "").replace(cwd + "/", "")).join("\n  ");
}
function formatArgs(args) {
    const fmtArgs = args.map((arg)=>{
        if (isObject(arg) && typeof arg.stack === "string") {
            return arg.message + "\n" + formatStack(arg.stack);
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return arg;
    });
    return fmtArgs.map((arg)=>{
        if (typeof arg === "string") {
            return arg;
        }
        return JSON.stringify(arg, null, 4);
    });
}
const logger = createConsola({
    reporters: [
        {
            log: (logObj)=>{
                const { type, tag, date, args } = logObj;
                const icon = icons[type];
                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);
                const lines = formatArgs(args).join(" ") // concat all arguments to one space-separated string (like console does)
                .split("\n") // split all the newlines (e.g. from logged JSON.stringified objects)
                .map((l)=>logPrefix + " " + l) // prepend the log prefix to each line
                .join("\n"); // join all the lines back together
                // eslint-disable-next-line no-console
                console.log(lines);
            }
        }
    ],
    defaults: {
        tag: "UPLOADTHING"
    }
});
const initLogger = (level)=>{
    // logger.wrapConsole();
    logger.level = LogLevels[level ?? "info"];
};

const isValidResponse = (response)=>{
    if (!response.ok) return false;
    if (response.status >= 400) return false;
    if (!response.headers.has("x-uploadthing-version")) return false;
    return true;
};
const conditionalDevServer = async (opts)=>{
    const fileData = await pollForFileData({
        url: generateUploadThingURL(`/api/pollUpload/${opts.fileKey}`),
        apiKey: opts.apiKey,
        sdkVersion: version,
        fetch: opts.fetch
    }, async (json)=>{
        const file = json.fileData;
        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
        if (!callbackUrl.startsWith("http")) callbackUrl = "http://" + callbackUrl;
        logger.info("SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
        try {
            const response = await opts.fetch(callbackUrl, {
                method: "POST",
                body: JSON.stringify({
                    status: "uploaded",
                    metadata: JSON.parse(file.metadata ?? "{}"),
                    file: {
                        url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,
                        key: opts.fileKey,
                        name: file.fileName,
                        size: file.fileSize,
                        type: file.fileType,
                        customId: file.customId
                    }
                }),
                headers: {
                    "uploadthing-hook": "callback"
                }
            });
            if (isValidResponse(response)) {
                logger.success("Successfully simulated callback for file", opts.fileKey);
            } else {
                throw new Error("Invalid response");
            }
        } catch (e) {
            logger.error(`Failed to simulate callback for file '${opts.fileKey}'. Is your webhook configured correctly?`);
            logger.error(`  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal`);
            logger.error(`  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues`);
        }
        return file;
    });
    if (fileData !== undefined) return fileData;
    logger.error(`Failed to simulate callback for file ${opts.fileKey}`);
    throw new UploadThingError({
        code: "UPLOAD_FAILED",
        message: "File took too long to upload"
    });
};

function getParseFn(parser) {
    if (typeof parser.parse === "function") {
        return parser.parse;
    }
    throw new Error("Invalid parser");
}

/**
 * Creates a wrapped fetch that will always forward a few headers to the server.
 */ const createUTFetch = (apiKey, fetch, fePackage, beAdapter)=>{
    return async (endpoint, payload)=>{
        const response = await fetch(generateUploadThingURL(endpoint), {
            method: "POST",
            body: JSON.stringify(payload),
            headers: {
                "Content-Type": "application/json",
                "x-uploadthing-api-key": apiKey,
                "x-uploadthing-version": version,
                "x-uploadthing-fe-package": fePackage,
                "x-uploadthing-be-adapter": beAdapter
            }
        });
        return response;
    };
};
const fileCountLimitHit = (files, routeConfig)=>{
    const counts = {};
    files.forEach((file)=>{
        const type = getTypeFromFileName(file.name, objectKeys(routeConfig));
        if (!counts[type]) {
            counts[type] = 1;
        } else {
            counts[type] += 1;
        }
    });
    for(const _key in counts){
        const key = _key;
        const count = counts[key];
        const limit = routeConfig[key]?.maxFileCount;
        if (!limit) {
            logger.error(routeConfig, key);
            throw new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid config during file count",
                cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`
            });
        }
        if (count > limit) {
            return {
                limitHit: true,
                type: key,
                limit,
                count
            };
        }
    }
    return {
        limitHit: false
    };
};
const buildRequestHandler = (opts, adapter)=>{
    return async (input)=>{
        const isDev = opts.config?.isDev ?? isDevelopment;
        const fetch = opts.config?.fetch ?? globalThis.fetch;
        if (isDev) {
            logger.info("UploadThing dev server is now running!");
        }
        const { router, config } = opts;
        const preferredOrEnvSecret = config?.uploadthingSecret ?? process.env.UPLOADTHING_SECRET;
        const req = input.req;
        const url = new URL(req.url);
        // Get inputs from query and params
        const params = url.searchParams;
        const uploadthingHook = req.headers.get("uploadthing-hook") ?? undefined;
        const slug = params.get("slug") ?? undefined;
        const actionType = params.get("actionType") ?? undefined;
        const utFrontendPackage = req.headers.get("x-uploadthing-package") ?? "unknown";
        const clientVersion = req.headers.get("x-uploadthing-version");
        if (clientVersion != null && clientVersion !== version) {
            logger.error("Client version mismatch");
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Client version mismatch",
                cause: `Server version: ${version}, Client version: ${clientVersion}`
            });
        }
        // Validate inputs
        if (!slug) {
            logger.error("No slug provided in params:", params);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "No slug provided in params"
            });
        }
        if (slug && typeof slug !== "string") {
            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;
            logger.error(msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`slug` must be a string",
                cause: msg
            });
        }
        if (actionType && typeof actionType !== "string") {
            const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;
            logger.error(msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`actionType` must be a string",
                cause: msg
            });
        }
        if (uploadthingHook && typeof uploadthingHook !== "string") {
            const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`uploadthingHook` must be a string",
                cause: msg
            });
        }
        if (!preferredOrEnvSecret) {
            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;
            logger.error(msg);
            return new UploadThingError({
                code: "MISSING_ENV",
                message: `No secret provided`,
                cause: msg
            });
        }
        if (!preferredOrEnvSecret.startsWith("sk_")) {
            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;
            logger.error(msg);
            return new UploadThingError({
                code: "MISSING_ENV",
                message: "Invalid API key. API keys must start with 'sk_'.",
                cause: msg
            });
        }
        if (utFrontendPackage && typeof utFrontendPackage !== "string") {
            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;
            logger.error(msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                message: "`x-uploadthing-package` must be a string. eg. '@uploadthing/react'",
                cause: msg
            });
        }
        const uploadable = router[slug];
        if (!uploadable) {
            const msg = `No file route found for slug ${slug}`;
            logger.error(msg);
            return new UploadThingError({
                code: "NOT_FOUND",
                message: msg
            });
        }
        const utFetch = createUTFetch(preferredOrEnvSecret, fetch, utFrontendPackage, adapter);
        logger.debug("All request input is valid", {
            slug,
            actionType,
            uploadthingHook
        });
        if (uploadthingHook === "callback") {
            // This is when we receive the webhook from uploadthing
            const maybeReqBody = await safeParseJSON(req);
            logger.debug("Handling callback request with input:", maybeReqBody);
            if (maybeReqBody instanceof Error) {
                logger.error("Invalid request body", maybeReqBody);
                return new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid request body",
                    cause: maybeReqBody
                });
            }
            const resolverArgs = {
                file: maybeReqBody.file,
                metadata: maybeReqBody.metadata
            };
            logger.debug("Running 'onUploadComplete' callback with input:", resolverArgs);
            const res = await uploadable.resolver(resolverArgs);
            const payload = {
                fileKey: maybeReqBody.file.key,
                callbackData: res ?? null
            };
            logger.debug("'onUploadComplete' callback finished. Sending response to UploadThing:", payload);
            const callbackResponse = await utFetch("/api/serverCallback", payload);
            logger.debug("UploadThing responded with status:", callbackResponse.status);
            return {
                status: 200,
                body: null
            };
        }
        if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {
            // This would either be someone spamming or the AWS webhook
            const msg = `Expected ${VALID_ACTION_TYPES.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${actionType}"`;
            logger.error("Invalid action type.", msg);
            return new UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid action type ${actionType}`,
                message: msg
            });
        }
        switch(actionType){
            case "upload":
                {
                    const maybeInput = await safeParseJSON(req);
                    if (maybeInput instanceof Error) {
                        logger.error("Invalid request body", maybeInput);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid request body",
                            cause: maybeInput
                        });
                    }
                    logger.debug("Handling upload request with input:", maybeInput);
                    const { files, input: userInput } = maybeInput;
                    // Validate without Zod (for now)
                    if (!Array.isArray(files) || !files.every((f)=>isObject(f) && typeof f.name === "string" && typeof f.size === "number" && typeof f.type === "string")) {
                        const msg = `Expected files to be of type '{name:string, size:number, type:string}[]', got '${JSON.stringify(files)}'`;
                        logger.error(msg);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Files must be an array of objects with name and size",
                            cause: msg
                        });
                    }
                    // validate the input
                    let parsedInput = {};
                    try {
                        logger.debug("Parsing input");
                        const inputParser = uploadable._def.inputParser;
                        parsedInput = await getParseFn(inputParser)(userInput);
                        logger.debug("Input parsed successfully", parsedInput);
                    } catch (error) {
                        logger.error("An error occurred trying to parse input:", error);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid input.",
                            cause: error
                        });
                    }
                    let metadata = {};
                    try {
                        logger.debug("Running middleware");
                        metadata = await uploadable._def.middleware({
                            ...input.middlewareArgs,
                            input: parsedInput,
                            files
                        });
                        logger.debug("Middleware finished successfully with:", metadata);
                    } catch (error) {
                        logger.error("An error occurred in your middleware function:", error);
                        if (error instanceof UploadThingError) return error;
                        return new UploadThingError({
                            code: "INTERNAL_SERVER_ERROR",
                            message: "Failed to run middleware.",
                            cause: error
                        });
                    }
                    if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {
                        const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;
                        logger.error(msg);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Files override must have the same length as files",
                            cause: msg
                        });
                    }
                    // Attach customIds from middleware to the files
                    const filesWithCustomIds = files.map((file, idx)=>{
                        const theirs = metadata[UTFiles]?.[idx];
                        if (theirs && theirs.size !== file.size) {
                            logger.warn("File size mismatch. Reverting to original size");
                        }
                        return {
                            name: theirs?.name ?? file.name,
                            size: file.size,
                            customId: theirs?.customId
                        };
                    });
                    // FILL THE ROUTE CONFIG so the server only has one happy path
                    let parsedConfig;
                    try {
                        logger.debug("Parsing route config", uploadable._def.routerConfig);
                        parsedConfig = fillInputRouteConfig(uploadable._def.routerConfig);
                        logger.debug("Route config parsed successfully", parsedConfig);
                    } catch (error) {
                        logger.error("Invalid route config", error);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid config.",
                            cause: error
                        });
                    }
                    try {
                        logger.debug("Checking file count limit", files);
                        const { limitHit, count, limit, type } = fileCountLimitHit(files, parsedConfig);
                        if (limitHit) {
                            const msg = `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`;
                            logger.error(msg);
                            return new UploadThingError({
                                code: "BAD_REQUEST",
                                message: "File limit exceeded",
                                cause: msg
                            });
                        }
                        logger.debug("File count limit check passed");
                    } catch (error) {
                        logger.error("Invalid route config", error);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid config.",
                            cause: error
                        });
                    }
                    const callbackUrl = resolveCallbackUrl({
                        config,
                        req,
                        url,
                        isDev
                    });
                    logger.debug("Retrieving presigned URLs from UploadThing. Callback URL is:", callbackUrl.href);
                    const uploadthingApiResponse = await utFetch("/api/prepareUpload", {
                        files: filesWithCustomIds,
                        routeConfig: parsedConfig,
                        metadata,
                        callbackUrl: callbackUrl.origin + callbackUrl.pathname,
                        callbackSlug: slug
                    });
                    // This is when we send the response back to the user's form so they can submit the files
                    const parsedResponse = await safeParseJSON(uploadthingApiResponse);
                    if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {
                        logger.error("Unable to get presigned URLs", parsedResponse);
                        return new UploadThingError({
                            code: "URL_GENERATION_FAILED",
                            message: "Unable to get presigned urls",
                            cause: parsedResponse
                        });
                    }
                    logger.debug("UploadThing responded with:", parsedResponse);
                    logger.debug("Sending presigned URLs to client");
                    // This is when we send the response back to the user's form so they can submit the files
                    let promise = undefined;
                    if (isDev) {
                        promise = Promise.all(parsedResponse.map((file)=>conditionalDevServer({
                                fileKey: file.key,
                                apiKey: preferredOrEnvSecret,
                                fetch
                            }).catch((error)=>{
                                logger.error("Err", error);
                            })));
                    }
                    return {
                        cleanup: promise,
                        body: parsedResponse,
                        status: 200
                    };
                }
            case "multipart-complete":
                {
                    const maybeReqBody = await safeParseJSON(req);
                    if (maybeReqBody instanceof Error) {
                        logger.error("Invalid request body", maybeReqBody);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid request body",
                            cause: maybeReqBody
                        });
                    }
                    logger.debug("Handling multipart-complete request with input:", maybeReqBody);
                    logger.debug("Notifying UploadThing that multipart upload is complete");
                    const completeRes = await utFetch("/api/completeMultipart", {
                        fileKey: maybeReqBody.fileKey,
                        uploadId: maybeReqBody.uploadId,
                        etags: maybeReqBody.etags
                    });
                    if (!completeRes.ok) {
                        logger.error("Failed to notify UploadThing that multipart upload is complete");
                        return new UploadThingError({
                            code: "UPLOAD_FAILED",
                            message: "Failed to complete multipart upload",
                            cause: completeRes
                        });
                    }
                    logger.debug("UploadThing responded with:", completeRes.status);
                    return {
                        status: 200,
                        body: null
                    };
                }
            case "failure":
                {
                    const maybeReqBody = await safeParseJSON(req);
                    if (maybeReqBody instanceof Error) {
                        logger.error("Invalid request body", maybeReqBody);
                        return new UploadThingError({
                            code: "BAD_REQUEST",
                            message: "Invalid request body",
                            cause: maybeReqBody
                        });
                    }
                    const { fileKey, uploadId } = maybeReqBody;
                    logger.debug("Handling failure request with input:", maybeReqBody);
                    logger.debug("Notifying UploadThing that upload failed");
                    // Tell uploadthing to mark the upload as failed
                    const uploadthingApiResponse = await utFetch("/api/failureCallback", {
                        fileKey,
                        uploadId
                    });
                    if (!uploadthingApiResponse.ok) {
                        const parsedResponse = await safeParseJSON(uploadthingApiResponse);
                        logger.error("Failed to mark upload as failed", parsedResponse);
                        return new UploadThingError({
                            code: "INTERNAL_SERVER_ERROR",
                            message: "Unable to mark upload as failed",
                            cause: parsedResponse
                        });
                    }
                    logger.debug("UploadThing responded with:", uploadthingApiResponse);
                    logger.debug("Running 'onUploadError' callback");
                    try {
                        // Run the onUploadError callback
                        uploadable._def.onUploadError({
                            error: new UploadThingError({
                                code: "UPLOAD_FAILED",
                                message: `Upload failed for ${fileKey}`
                            }),
                            fileKey
                        });
                    } catch (error) {
                        logger.error("Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.", error);
                        return new UploadThingError({
                            code: "INTERNAL_SERVER_ERROR",
                            message: "Failed to run onUploadError callback",
                            cause: error
                        });
                    }
                    return {
                        status: 200,
                        body: null
                    };
                }
            default:
                {
                    // This should never happen
                    return new UploadThingError({
                        code: "BAD_REQUEST",
                        message: `Invalid action type`
                    });
                }
        }
    };
};
function resolveCallbackUrl(opts) {
    let callbackUrl = opts.url;
    if (opts.config?.callbackUrl) {
        callbackUrl = resolveMaybeUrlArg(opts.config.callbackUrl);
    } else if (process.env.UPLOADTHING_URL) {
        callbackUrl = resolveMaybeUrlArg(process.env.UPLOADTHING_URL);
    }
    if (opts.isDev || !callbackUrl.host.includes("localhost")) {
        return callbackUrl;
    }
    // Production builds have to have a public URL so UT can send webhook
    // Parse the URL from the headers
    const headers = opts.req.headers;
    let parsedFromHeaders = headers.get("origin") ?? headers.get("referer") ?? headers.get("host") ?? headers.get("x-forwarded-host");
    if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
        parsedFromHeaders = (headers.get("x-forwarded-proto") ?? "https") + "://" + parsedFromHeaders;
    }
    if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
        // Didn't find a valid URL in the headers, log a warning and use the original url anyway
        logger.warn("You are using a localhost callback url in production which is not supported.", "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production");
        return callbackUrl;
    }
    return resolveMaybeUrlArg(parsedFromHeaders);
}
const buildPermissionsInfoHandler = (opts)=>{
    return ()=>{
        const r = opts.router;
        const permissions = Object.keys(r).map((k)=>{
            const route = r[k];
            const config = fillInputRouteConfig(route._def.routerConfig);
            return {
                slug: k,
                config
            };
        });
        return permissions;
    };
};

function incompatibleNodeGuard() {
    if (typeof process === "undefined") return;
    let major;
    let minor;
    const maybeNodeVersion = process.versions?.node?.split(".");
    if (maybeNodeVersion) {
        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));
    }
    const maybeNodePath = process.env?.NODE;
    if (!major && maybeNodePath) {
        const nodeVersion = /v(\d+)\.(\d+)\.(\d+)/.exec(maybeNodePath)?.[0];
        if (nodeVersion) {
            [major, minor] = nodeVersion.substring(1).split(".").map((v)=>parseInt(v, 10));
        }
    }
    if (!major || !minor) return;
    // Require ^18.13.0
    if (major > 18) return;
    if (major === 18 && minor >= 13) return;
    logger.fatal(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`);
    // Kill the process if it isn't going to work correctly anyway
    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
    process.exit?.(1);
}

async function getPostBody(opts) {
    const { req, maxBodySize = Infinity } = opts;
    return new Promise((resolve)=>{
        if ("body" in req) {
            const contentType = req.headers["content-type"];
            if (contentType !== "application/json") {
                logger.error("Expected JSON content type, got:", contentType);
                resolve({
                    ok: false,
                    error: new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "INVALID_CONTENT_TYPE"
                    })
                });
                return;
            }
            if (typeof req.body !== "object") {
                logger.error("Expected body to be of type 'object', got:", typeof req.body);
                resolve({
                    ok: false,
                    error: new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "INVALID_BODY"
                    })
                });
                return;
            }
            logger.debug("Body parsed successfully.", req.body);
            resolve({
                ok: true,
                data: req.body
            });
            return;
        }
        let body = "";
        let hasBody = false;
        req.on("data", function(data) {
            body += data;
            hasBody = true;
            if (body.length > maxBodySize) {
                logger.error("Body too large, max size is", maxBodySize, "bytes but received", body.length, "bytes");
                resolve({
                    ok: false,
                    error: new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "PAYLOAD_TOO_LARGE"
                    })
                });
                req.socket.destroy();
            }
        });
        req.on("end", ()=>{
            let parsedBody;
            try {
                logger.debug("Finished reading body, parsing as JSON", body);
                parsedBody = JSON.parse(body);
            } catch (e) {
                logger.error("Error parsing JSON:", body);
                resolve({
                    ok: false,
                    error: new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "INVALID_JSON",
                        cause: e
                    })
                });
                return;
            }
            logger.debug("Body parsed successfully.", parsedBody);
            resolve({
                ok: true,
                data: hasBody ? parsedBody : undefined
            });
        });
    });
}

function parseURL(req) {
    const headers = req.headers;
    let relativeUrl = req.url ?? "/";
    if ("baseUrl" in req && typeof req.baseUrl === "string") {
        relativeUrl = req.baseUrl + relativeUrl;
    }
    const proto = headers?.["x-forwarded-proto"] ?? "http";
    const host = headers?.["x-forwarded-host"] ?? headers?.host;
    if (typeof proto !== "string" || typeof host !== "string") {
        try {
            return new URL(relativeUrl, process.env.UPLOADTHING_URL);
        } catch (e) {
            logger.error(`Failed to parse URL from request. No headers found and env.UPLOADTHING_URL is not a valid URL.`);
            throw e;
        }
    }
    try {
        return new URL(`${proto}://${host}${relativeUrl}`);
    } catch (e) {
        logger.error(`Failed to parse URL from request. '${proto}://${host}${relativeUrl}' is not a valid URL.`);
        throw e;
    }
}
function toWebRequest(req, body) {
    body ??= req.body;
    const bodyStr = typeof body === "string" ? body : JSON.stringify(body);
    const method = req.method ?? "GET";
    const allowsBody = [
        "POST",
        "PUT",
        "PATCH"
    ].includes(method);
    return new Request(parseURL(req), {
        method,
        headers: req.headers,
        ...allowsBody ? {
            body: bodyStr
        } : {}
    });
}

function internalCreateBuilder(initDef = {}) {
    const _def = {
        // Default router config
        routerConfig: {
            image: {
                maxFileSize: "4MB"
            }
        },
        inputParser: {
            parse: ()=>undefined,
            _input: undefined,
            _output: undefined
        },
        middleware: ()=>({}),
        onUploadError: ()=>({}),
        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
        // Overload with properties passed in
        ...initDef
    };
    return {
        input (userParser) {
            return internalCreateBuilder({
                ..._def,
                inputParser: userParser
            });
        },
        middleware (userMiddleware) {
            return internalCreateBuilder({
                ..._def,
                middleware: userMiddleware
            });
        },
        onUploadComplete (userUploadComplete) {
            return {
                _def,
                resolver: userUploadComplete
            };
        },
        onUploadError (userOnUploadError) {
            return internalCreateBuilder({
                ..._def,
                onUploadError: userOnUploadError
            });
        }
    };
}
function createBuilder(opts) {
    return (input)=>{
        return internalCreateBuilder({
            routerConfig: input,
            ...opts
        });
    };
}

const createUploadthing = (opts)=>createBuilder(opts);
const createRouteHandler = (opts)=>{
    initLogger(opts.config?.logLevel);
    incompatibleNodeGuard();
    const requestHandler = buildRequestHandler(opts, "express");
    const getBuildPerms = buildPermissionsInfoHandler(opts);
    const router = Router();
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    router.post("/", async (req, res)=>{
        const bodyResult = await getPostBody({
            req
        });
        if (!bodyResult.ok) {
            logger.error("Error parsing body. UploadThing expects a raw JSON body, make sure any body-parsing middlewares are registered after uploadthing.");
            res.status(400);
            res.setHeader("x-uploadthing-version", version);
            res.send(JSON.stringify({
                error: "BAD_REQUEST",
                message: bodyResult.error.message
            }));
            return;
        }
        const response = await requestHandler({
            req: toWebRequest(req, bodyResult.data),
            middlewareArgs: {
                req,
                res,
                event: undefined
            }
        });
        if (response instanceof UploadThingError) {
            res.status(getStatusCodeFromError(response));
            res.setHeader("x-uploadthing-version", version);
            res.send(JSON.stringify(formatError(response, opts.router)));
            return;
        }
        if (response.status !== 200) {
            // We messed up - this should never happen
            res.status(500);
            res.setHeader("x-uploadthing-version", version);
            res.send("An unknown error occurred");
            return;
        }
        res.status(response.status);
        res.setHeader("x-uploadthing-version", version);
        res.send(JSON.stringify(response.body));
    });
    router.get("/", (_req, res)=>{
        res.status(200);
        res.setHeader("x-uploadthing-version", version);
        res.send(JSON.stringify(getBuildPerms()));
    });
    return router;
};
/**
 * @deprecated Use {@link createRouteHandler} instead
 */ const createUploadthingExpressHandler = createRouteHandler;

export { createRouteHandler, createUploadthing, createUploadthingExpressHandler };
